<!doctype html>
<html>
<head>
<title>Mesh Drawing</title>
	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
	</style>

	<script src="libs/gl-matrix-min.js"></script>
	<script src="libs/webgl-obj-loader.js"></script>
	<script src="libs/transformation.js"></script>
	<script src="libs/noisejs-master/perlin.js"></script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat4 oLWMatrix;
		varying highp vec4 vColor;
		void main(void) {
			gl_Position = uPMatrix * uMVMatrix * oLWMatrix * vec4(aVertexPosition, 1.0);
			vColor = vec4(1.0, 1.0, 1.0, 1.0);
		}
	</script>
	<script id="shader-fs" type="x-shader/x-fragment">
		varying highp vec4 vColor;
		void main(void) {
			gl_FragColor = vColor;
		}
	</script>

	<script id ="shader-fs-red" type="x-shader/x-fragment">
		varying highp vec4 vColor;
		void main(void) {
			gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
		}
	</script>

	<script>
		let gl = null,
			canvas = null,
			glProgram = null,
			glProgram2 = null,
			fragmentShader = null,
			vertexShader = null,
			redFragmentShader = null;

		let vertexPositionAttribute = null,
			trianglesVerticeBuffer = null,
			vertexColorAttribute = null,
			trianglesColorBuffer = null;

		let lwMatrix1 = mat4.create(),
			lwMatrix2 = mat4.create(),
			mvMatrix = mat4.create(),
			pMatrix = mat4.create();

		let rotateValue = 0.0;

		// Read the mesh file as text
		let meshStr = readTextFile("meshes/skull/skull.obj");
		
		// Load the mesh from obj text
		let meshObj = new OBJ.Mesh(meshStr);


		function initWebGL()
		{
			canvas = document.getElementById("my-canvas");
			gl = canvas.getContext("experimental-webgl");

			canvas.onmousedown = function(e) {
				console.log("Mouse down at: " + e.clientX + ", " + e.clientY);
			};

			if(gl)
			{
				// enable depth testing for correct 3D rendering
				gl.enable(gl.DEPTH_TEST);
				initBuffers();
				initShaders();
				initMatrixUniforms();
				animLoop();
			}else{
				alert( "Error: Your browser does not appear to" + "support WebGL.");
			}
		}

		function animLoop()
		{
			updateWebGL();
			updateBuffers();
			updateMatrixUniforms();
			drawScene();
			requestAnimationFrame(animLoop, canvas);
		}

		function updateWebGL()
		{
			//set the clear color to a shade of green
			gl.clearColor(0.1, 0.1, 0.1, 1.0);
			// clear color and depth buffers
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			//set viewport
			gl.viewport(0, 0, canvas.width, canvas.height);

			let timestamp = performance.now() / 1000;
			const frequency = 1.0;
			const sinValue = Math.sin(timestamp * frequency);

			//set view and projection matrix
			mat4.perspective(45, canvas.width / canvas.height, 0.1, 100.0, pMatrix);
			mat4.identity(mvMatrix);
			mat4.translate(mvMatrix, [0, 0, -10.0]);
			mat4.translate(mvMatrix, [0, sinValue, 0]);
			

			// update two per-object local-to-world matrices
			mat4.identity(lwMatrix1);
			mat4.translate(lwMatrix1, [-1, 0, -5]);

			mat4.identity(lwMatrix2);
			mat4.translate(lwMatrix2, [1, 0, -5]);

			rotateValue += 0.02;
			let rotAxis = new Array(0,1,0);
			mat4.rotate(lwMatrix1, rotateValue, rotAxis, null);
			mat4.rotate(lwMatrix2, -rotateValue, rotAxis, null);
			// mat4.rotate(mvMatrix, rotateValue, rotAxis, null);

		}

		function initShaders()
		{
			//get shader source
			let fs_source = document.getElementById('shader-fs').innerHTML,
			vs_source = document.getElementById('shader-vs').innerHTML,
			red_fs_source = document.getElementById('shader-fs-red').innerHTML;

			//compile shaders
			// makeShader(code, type)
			vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);

			fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
			redFragmentShader = makeShader(red_fs_source, gl.FRAGMENT_SHADER);

			// create, attach and link first program
			glProgram = gl.createProgram();
			gl.attachShader(glProgram, vertexShader);
			gl.attachShader(glProgram, fragmentShader);
			gl.linkProgram(glProgram);

			// create, attach and link second (red) program
			glProgram2 = gl.createProgram();
			gl.attachShader(glProgram2, vertexShader);
			gl.attachShader(glProgram2, redFragmentShader);
			gl.linkProgram(glProgram2);

			console.log('Program 1 log:', gl.getProgramInfoLog(glProgram));
			console.log('Program 2 log:', gl.getProgramInfoLog(glProgram2));

			if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
				alert("Unable to initialize the shader program (program 1).\n" + gl.getProgramInfoLog(glProgram));
			}
			if (!gl.getProgramParameter(glProgram2, gl.LINK_STATUS)) {
				alert("Unable to initialize the shader program (program 2).\n" + gl.getProgramInfoLog(glProgram2));
			}
		}

		function makeShader(src, type)
		{
			//compile the vertex shader
			let shader = gl.createShader(type);
			gl.shaderSource(shader, src);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
			}
			return shader;
		}

		function initBuffers()
		{
			// initialize WebGL buffers for the mesh (positions, indices, normals)
			OBJ.initMeshBuffers( gl, meshObj );
		}

		function updateBuffers()
		{

		}

		function drawScene()
		{
			// use the program before querying attribute locations
			gl.useProgram(glProgram);

			// set up the vertex attribute for positions
			vertexPositionAttribute = gl.getAttribLocation(glProgram, "aVertexPosition");
			gl.enableVertexAttribArray(vertexPositionAttribute);
			gl.bindBuffer(gl.ARRAY_BUFFER, meshObj.vertexBuffer);
			gl.vertexAttribPointer(vertexPositionAttribute, 3,
				gl.FLOAT, false, 0, 0);

			// bind index buffer once
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshObj.indexBuffer);

			// draw first instance
			gl.uniformMatrix4fv(glProgram.lwMatrixUniform, false, lwMatrix1);
			gl.drawElements(gl.TRIANGLES, meshObj.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

			// draw second instance (same mesh, different local-to-world matrix)
			gl.uniformMatrix4fv(glProgram.lwMatrixUniform, false, lwMatrix2);
			gl.drawElements(gl.TRIANGLES, meshObj.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

		}

		function initMatrixUniforms(){
			glProgram.pMatrixUniform = gl.getUniformLocation(glProgram, "uPMatrix");
			glProgram.mvMatrixUniform = gl.getUniformLocation(glProgram, "uMVMatrix");
			glProgram.lwMatrixUniform = gl.getUniformLocation(glProgram, "oLWMatrix");
		}

		function updateMatrixUniforms() {
			gl.uniformMatrix4fv(glProgram.pMatrixUniform, false, pMatrix);
			gl.uniformMatrix4fv(glProgram.mvMatrixUniform, false, mvMatrix);
			// per-object lw matrices are uploaded per-instance in drawScene
		}

		function readTextFile(file)
		{
		    let rawFile = new XMLHttpRequest();
		    let strText;
		    rawFile.open("GET", file, false);
		    rawFile.onreadystatechange = function ()
		    {
		        if(rawFile.readyState === 4)
		        {
		            if(rawFile.status === 200 || rawFile.status == 0)
		            {
		                strText = rawFile.responseText;
		            }
		        }
		    }
		    rawFile.send(null);
		    return strText;
		}

	</script>

</head>

<body onload="initWebGL()">
	<canvas id="my-canvas" width="1000" height="800">
		Your browser does not support the HTML5 canvas element.
	</canvas>
</body>

</html>
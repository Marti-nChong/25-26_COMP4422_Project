<!doctype html>
<html>
<head>
<title>Mesh Drawing</title>
	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
	</style>

	<script src="libs/gl-matrix-min.js"></script>
	<script src="libs/webgl-obj-loader.js"></script>
	<script src="libs/my3DObject.js"></script>
	<script src="libs/noisejs-master/perlin.js"></script>
	<script src="libs/webgl-utils.js"></script>
	
	<script>
		let gl = null,
			canvas = null;

		let	myCameraObj = new myCamera();
		let myTestCameraObj = new myCamera();

		let pMatrix = mat4.create();
		let vMatrix = mat4.create();

		let rotateValue = 0.0;
		let mySceneObjects = [];

		let FBO, fboTexture, depthTexture, quadProgram, quadBuffer;

		// Read the mesh file as text
		let skullMeshStr = readTextFile("meshes/stool.obj");
		let cubeMeshStr = readTextFile("meshes/cube.obj");
		let dirtyCarStr = readTextFile("meshes/dirty-car/source/dirtyCar.obj");
		
		let myMeshObj = new my3DObject(dirtyCarStr);
		let myMeshObj2 = new my3DObject(skullMeshStr);
		myMeshObj.name = "object1";
		myMeshObj2.name = "object2";


		
		let mainDirectionLight = vec3.create();
		vec3.set([0.0, -1.0, 0.0], mainDirectionLight);

		console.log("Main light direction: " + mainDirectionLight);

		function initWebGL()
		{
			canvas = document.getElementById("my-canvas");
			gl = canvas.getContext("webgl2") || canvas.getContext("experimental-webgl");

			canvas.onmousedown = function(e) {
				console.log("Mouse down at: " + e.clientX + ", " + e.clientY);
			};

			if(gl)
			{
				// enable depth testing for correct 3D rendering
				gl.enable(gl.DEPTH_TEST);
				gl.clearDepth(1.0);

				const ext = gl.getExtension('WEBGL_depth_texture');

				// Create FBO texture
				fboTexture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, fboTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				// Create depth texture
				depthTexture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, depthTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT24, canvas.width, canvas.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

				// Create FBO
				FBO = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, FBO);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fboTexture, 0);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				
				// Create quad program
				let quadVS = `
					attribute vec2 aPosition;
					attribute vec2 aTexCoord;
					varying vec2 vTexCoord;
					void main() {
						gl_Position = vec4(aPosition, 0.0, 1.0);
						vTexCoord = aTexCoord;
					}
				`;
				let quadFS = `
					precision mediump float;
					uniform sampler2D uTexture;
					uniform sampler2D uDepthTexture;
					varying vec2 vTexCoord;
					void main() {
						vec4 color = texture2D(uTexture, vTexCoord);
						float depth = texture2D(uDepthTexture, vTexCoord).r;
						gl_FragColor = vec4(color.rgb, 1.0);
						gl_FragColor = vec4(vec3(depth), 1.0);
						
						float vizDepth = 1.0 - pow(depth, 90.0);
						gl_FragColor = max(vec4(1.0 - vec3(1.0 - color.r, 1.0 - color.g, 1.0 - color.b) * ( 1.0 - vizDepth), 1.0), color);
						// gl_FragColor = vec4(vec3(vizDepth), 1.0);
						// gl_FragColor = color * vec4(vec3(vizDepth), 1.0);

					}
				`;
				let vertexShader = makeShader(quadVS, gl.VERTEX_SHADER);
				let fragmentShader = makeShader(quadFS, gl.FRAGMENT_SHADER);
				quadProgram = gl.createProgram();
				gl.attachShader(quadProgram, vertexShader);
				gl.attachShader(quadProgram, fragmentShader);
				gl.linkProgram(quadProgram);
				if (!gl.getProgramParameter(quadProgram, gl.LINK_STATUS)) {
					alert("Unable to initialize quad shader program.");
				}
				quadProgram.positionAttribute = gl.getAttribLocation(quadProgram, "aPosition");
				quadProgram.texCoordAttribute = gl.getAttribLocation(quadProgram, "aTexCoord");
				quadProgram.textureUniform = gl.getUniformLocation(quadProgram, "uTexture");
				quadProgram.depthTextureUniform = gl.getUniformLocation(quadProgram, "uDepthTexture");
				console.log(quadProgram)
				console.log(quadProgram.positionAttribute)
				console.log(quadProgram.texCoordAttribute)
				console.log(quadProgram.textureUniform)
				console.log(quadProgram.depthTextureUniform)

				// Quad vertices: position x,y, tex u,v
				let quadVertices = new Float32Array([
					-1, -1, 0, 0,
					 1, -1, 1, 0,
					-1,  1, 0, 1,
					 1,  1, 1, 1
				]);
				quadBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

				let vs_r_source = readTextFile("shader/vs_lit.vert");
				let fs_r_source = readTextFile("shader/fs_lit.frag");

				myMeshObj.init(vs_r_source, fs_r_source);
				myMeshObj2.init(vs_r_source, fs_r_source);
				myMeshObj.loadTexture("meshes/dirty-car/textures/large_car_d.tga.png");
				myMeshObj.loadNormalTexture("meshes/dirty-car/textures/large_car_ddna.tga.png");
				myMeshObj2.loadTexture("meshes/textures/Material_albedo.jpeg");
				myMeshObj2.loadNormalTexture("meshes/textures/Material_normal.png");

				mySceneObjects.push(myMeshObj);
				mySceneObjects.push(myMeshObj2);

				myMeshObj.toOrigin();
				myMeshObj2.toOrigin();
				
				scale = vec3.create();
				vec3.set([1.0, 1.0, 1.0], scale);
				vec3.scale(scale, 2.0, scale);
				console.log("Scale vector: " + scale);

				myMeshObj.translate(-4, -1, -1);
				myMeshObj.scale(scale[0], scale[1], scale[2]);
				myMeshObj2.translate(4, -1, -5);
				myMeshObj2.scale(scale[0], scale[1], scale[2]);
				animLoop();
			}else{
				alert( "Error: Your browser does not appear to" + "support WebGL.");
			}
		}

		function animLoop()
		{
			updateWebGL();
			updateBuffers();
			drawScene();
			requestAnimationFrame(animLoop, canvas);
		}

		function updateCamera(camera, vMatrix, pMatrix){
			camera.setViewMatrix(vMatrix);
			camera.setProjectionMatrix(pMatrix);
		}

		function updateWebGL()
		{
			//set the clear color to a shade of green
			gl.clearColor(0.4, 0.4, 0.4, 1.0);
			// clear color and depth buffers
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			//set viewport
			gl.viewport(0, 0, canvas.width, canvas.height);

			let timestamp = performance.now() / 1000;
			const frequency = 0.0;
			const sinValue = Math.sin(timestamp * frequency);

			updateCamera(myCameraObj);
			//set view and projection matrix
			mat4.perspective(45, canvas.width / canvas.height, 0.1, 100.0, pMatrix);
			mat4.identity(vMatrix);
			mat4.translate(vMatrix, [0, 0, -10.0]);
			mat4.translate(vMatrix, [0, sinValue, 0]);

			let pMat4sec = mat4.create();
			mat4.perspective(45, canvas.width / canvas.height, 0.1, 100.0, pMat4sec);
			let vMat4sec = mat4.create();
			mat4.identity(vMat4sec);
			mat4.translate(vMat4sec, [0, 0, -20.0]);
			
			
			updateCamera(myCameraObj, vMatrix, pMatrix);
			updateCamera(myTestCameraObj, vMatrix, pMatrix);
			updateCamera(myTestCameraObj, vMat4sec, pMat4sec);

			let rotAxis = new Array(0,1,0);
			let rotateAngleMax = 45.0 * Math.PI / 180.0; // 45 degrees in radians
			let rotateAngle = rotateAngleMax * Math.sin(timestamp);
			// mat4.rotate(vMatrix, rotateAngle, rotAxis);

			myMeshObj.rotate(rotateValue, rotAxis);
			myMeshObj2.rotate(-rotateValue, rotAxis);

		}


		function updateBuffers()
		{
			// no dynamic buffers to update in this example
		}


		function drawScene()
		{

			// Render to FBO
			gl.bindFramebuffer(gl.FRAMEBUFFER, FBO);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			myMeshObj.draw(myCameraObj);
			myMeshObj2.draw(myCameraObj);

			// Render to screen
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Draw quad with FBO texture
			gl.useProgram(quadProgram);
			gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
			gl.enableVertexAttribArray(quadProgram.positionAttribute);
			gl.vertexAttribPointer(quadProgram.positionAttribute, 2, gl.FLOAT, false, 16, 0);
			gl.enableVertexAttribArray(quadProgram.texCoordAttribute);
			gl.vertexAttribPointer(quadProgram.texCoordAttribute, 2, gl.FLOAT, false, 16, 8);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, fboTexture);
			gl.uniform1i(quadProgram.textureUniform, 0);

			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, depthTexture);
			gl.uniform1i(quadProgram.depthTextureUniform, 1);
			
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		}

		function readTextFile(file)
		{
		    let rawFile = new XMLHttpRequest();
		    let strText;
		    rawFile.open("GET", file, false);
		    rawFile.onreadystatechange = function ()
		    {
		        if(rawFile.readyState === 4)
		        {
		            if(rawFile.status === 200 || rawFile.status == 0)
		            {
		                strText = rawFile.responseText;
		            }
		        }
		    }
		    rawFile.send(null);
		    return strText;
		}

		function makeShader(src, type)
		{
			//compile the vertex shader
			let shader = gl.createShader(type);
			gl.shaderSource(shader, src);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
			}
			return shader;
		}

	</script>

</head>

<body onload="initWebGL()">
	<canvas id="my-canvas" width="1000" height="800">
		Your browser does not support the HTML5 canvas element.
	</canvas>
</body>

</html>
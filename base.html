<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Adjust Objects Freely</title>
    <style> body { margin: 0; overflow: hidden; background: #000; } </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 1, 20);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 2. LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        scene.add(hemiLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- 3. AXIS HELPER ---
        const axesHelper = new THREE.AxesHelper(5);
        axesHelper.position.set(0, 0, -2);
        scene.add(axesHelper);

        // --- 4. ASSET LOADER (UPDATED FOR ASSIGNMENT) ---
        const fbxLoader = new FBXLoader();
        const texLoader = new THREE.TextureLoader();

        /**
         * Returns a THREE.Group immediately. The model loads into it later.
         */
        function loadAsset(folderPath, x, y, z, scale = 0.01) {
            
            // 1. Create a "Wrapper" Group immediately
            const wrapper = new THREE.Group();
            
            // 2. Set the position of the wrapper immediately
            wrapper.position.set(x, y, z);
            
            // 3. Add wrapper to scene
            scene.add(wrapper);

            // 4. Start loading the Heavy Assets (Async)
            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (model) => {
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({
                            map: albedoMap,
                            normalMap: normalMap,
                            roughness: 0.5,
                            metalness: 0.1
                        });
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // Apply the scale correction to the INNER model
                model.scale.set(scale, scale, scale);
                
                // Add the loaded model INTO the wrapper
                wrapper.add(model);
                
                console.log(`Loaded Asset: ${path}`);
            }, undefined, (err) => console.error(err));

            // 5. Return the wrapper so you can save it to a variable
            return wrapper;
        }

        // ===============================================
        // LOAD ASSETS & ASSIGN TO VARIABLES
        // ===============================================
        
        // 1. Original Object at y = -2
        let obj1 = loadAsset('meshes/obj0', 0, -2, 3, 0.01); 

        // 2. New Object at y = -2, z = -10, Scale 0.25
        let obj2 = loadAsset('meshes/obj1', 0, -0.35, -7, 0.015);

		obj2.rotation.y = Math.PI/2; // Rotate 180 degrees immediately

        // EXAMPLE: You can now adjust them here or in the loop!
        // obj2.rotation.y = Math.PI / 2; // Rotate 90 degrees immediately
        
        // ===============================================

        // --- 5. MOUSE CONTROLS ---
        const MAX_DEGREE = 5; 
        const SMOOTHING = 0.05;
        const maxRad = MAX_DEGREE * (Math.PI / 180);
        const mouse = { x: 0, y: 0 };

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // --- 6. SKY CYCLE ---
        const clock = new THREE.Clock();
        const skyColors = [
            new THREE.Color(0x87CEEB), 
            new THREE.Color(0xFFA500), 
            new THREE.Color(0x050510), 
            new THREE.Color(0x8a76ab)
        ];

        function updateSky() {
            const time = clock.getElapsedTime();
            const duration = 10; 
            const progress = (time % duration) / duration;
            const segmentCount = skyColors.length;
            const segmentIndex = Math.floor(progress * segmentCount);
            const nextIndex = (segmentIndex + 1) % segmentCount;
            const subProgress = (progress * segmentCount) % 1;
            const colorCurrent = skyColors[segmentIndex];
            const colorNext = skyColors[nextIndex];
            const finalColor = colorCurrent.clone().lerp(colorNext, subProgress);
            scene.background = finalColor;
            scene.fog.color = finalColor;
        }

        // --- 7. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            updateSky();

            // EXAMPLE: You can even animate obj2 here easily now!
            // obj2.rotation.y += 0.01;

            const targetRotationX = mouse.y * maxRad; 
            const targetRotationY = -mouse.x * maxRad; 
            camera.rotation.x += (targetRotationX - camera.rotation.x) * SMOOTHING;
            camera.rotation.y += (targetRotationY - camera.rotation.y) * SMOOTHING;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
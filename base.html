<!doctype html>
<html>
<head>
<title>Mesh Drawing</title>
	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
	</style>

	<script src="libs/gl-matrix-min.js"></script>
	<script src="libs/webgl-obj-loader.js"></script>
	<script src="libs/my3DObject.js"></script>
	<script src="libs/noisejs-master/perlin.js"></script>
	<script src="libs/webgl-utils.js"></script>
	
	<script>
		let gl = null,
			canvas = null;

		let	myCameraObj = new myCamera();
		let myTestCameraObj = new myCamera();

		let rotateValue = 0.0;
		let mySceneObjects = [];

		// Read the mesh file as text
		let skullMeshStr = readTextFile("meshes/stool.obj");
		let cubeMeshStr = readTextFile("meshes/cube.obj");
		let dirtyCarStr = readTextFile("meshes/dirty-car/source/dirtyCar.obj");
		
		let myMeshObj = new my3DObject(dirtyCarStr);
		let myMeshObj2 = new my3DObject(skullMeshStr);
		myMeshObj.name = "object1";
		myMeshObj2.name = "object2";


		
		let mainDirectionLight = vec3.create();
		vec3.set([0.0, -1.0, 0.0], mainDirectionLight);

		console.log("Main light direction: " + mainDirectionLight);

		function initWebGL()
		{
			canvas = document.getElementById("my-canvas");
			gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

			canvas.onmousedown = function(e) {
				console.log("Mouse down at: " + e.clientX + ", " + e.clientY);
			};

			if(gl)
			{
				// enable depth testing for correct 3D rendering
				gl.enable(gl.DEPTH_TEST);
				gl.clearDepth(1.0);

				let vs_r_source = readTextFile("shader/vs_lit.vert");
				let fs_r_source = readTextFile("shader/fs_lit.frag");

				myMeshObj.init(vs_r_source, fs_r_source);
				myMeshObj2.init(vs_r_source, fs_r_source);
				myMeshObj.loadTexture("meshes/dirty-car/textures/large_car_d.tga.png");
				myMeshObj.loadNormalTexture("meshes/dirty-car/textures/large_car_ddna.tga.png");
				myMeshObj2.loadTexture("meshes/textures/Material_albedo.jpeg");
				myMeshObj2.loadNormalTexture("meshes/textures/Material_normal.png");

				mySceneObjects.push(myMeshObj);
				mySceneObjects.push(myMeshObj2);

				myMeshObj.toOrigin();
				myMeshObj2.toOrigin();
				
				scale = vec3.create();
				vec3.set([1.0, 1.0, 1.0], scale);
				vec3.scale(scale, 2.0, scale);
				console.log("Scale vector: " + scale);

				myMeshObj.translate(-4, -1, -1);
				myMeshObj.scale(scale[0], scale[1], scale[2]);
				myMeshObj2.translate(4, -1, -5);
				myMeshObj2.scale(scale[0], scale[1], scale[2]);
				animLoop();
			}else{
				alert( "Error: Your browser does not appear to" + "support WebGL.");
			}
		}

		function animLoop()
		{
			updateWebGL();
			updateBuffers();
			drawScene();
			requestAnimationFrame(animLoop, canvas);
		}

		function updateCamera(camera, vMatrix, pMatrix){
			camera.setViewMatrix(vMatrix);
			camera.setProjectionMatrix(pMatrix);
		}

		function updateWebGL()
		{
			//set the clear color to a shade of green
			gl.clearColor(0.4, 0.4, 0.4, 1.0);
			// clear color and depth buffers
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			//set viewport
			gl.viewport(0, 0, canvas.width, canvas.height);

			let timestamp = performance.now() / 1000;
			const frequency = 0.0;
			const sinValue = Math.sin(timestamp * frequency);

			updateCamera(myCameraObj);
			//set view and projection matrix
			let vMat4 = mat4.create();
			let pMat4 = mat4.create();
			mat4.perspective(45, canvas.width / canvas.height, 0.1, 100.0, pMat4);
			mat4.identity(vMat4);
			mat4.translate(vMat4, [0, 0, -10.0]);
			mat4.translate(vMat4, [0, sinValue, 0]);

			let pMat4sec = mat4.create();
			mat4.perspective(45, canvas.width / canvas.height, 0.1, 100.0, pMat4sec);
			let vMat4sec = mat4.create();
			mat4.identity(vMat4sec);
			mat4.translate(vMat4sec, [0, 0, -20.0]);
			
			
			updateCamera(myCameraObj, vMat4, pMat4);
			updateCamera(myTestCameraObj, vMat4, pMat4);
			updateCamera(myTestCameraObj, vMat4sec, pMat4sec);

			let rotAxis = new Array(0,1,0);
			let rotateAngleMax = 45.0 * Math.PI / 180.0; // 45 degrees in radians
			let rotateAngle = rotateAngleMax * Math.sin(timestamp);
			// mat4.rotate(vMatrix, rotateAngle, rotAxis);

			myMeshObj.rotate(rotateValue, rotAxis);
			myMeshObj2.rotate(-rotateValue, rotAxis);

		}


		function updateBuffers()
		{
			// no dynamic buffers to update in this example
		}


		function drawScene()
		{
			myMeshObj.draw(myCameraObj);
			myMeshObj2.draw(myTestCameraObj);


			// for (let obj of mySceneObjects) {
			// 	obj.draw(myCameraObj);
			// }
		}

		function readTextFile(file)
		{
		    let rawFile = new XMLHttpRequest();
		    let strText;
		    rawFile.open("GET", file, false);
		    rawFile.onreadystatechange = function ()
		    {
		        if(rawFile.readyState === 4)
		        {
		            if(rawFile.status === 200 || rawFile.status == 0)
		            {
		                strText = rawFile.responseText;
		            }
		        }
		    }
		    rawFile.send(null);
		    return strText;
		}

	</script>

</head>

<body onload="initWebGL()">
	<canvas id="my-canvas" width="1000" height="800">
		Your browser does not support the HTML5 canvas element.
	</canvas>
</body>

</html>
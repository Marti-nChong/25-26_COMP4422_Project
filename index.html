<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>2025_11_29</title>
    <style> 
        body { margin: 0; overflow: hidden; background: #87CEEB; } 
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui-container" style="position: absolute; top: 20px; left: 20px; z-index: 100; color: white; font-family: sans-serif; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;">
        <h3 style="margin-top: 0;">Controls</h3>
        <p style="margin: 0;">Press SPACE to toggle Day/Night</p>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { FlyControls } from 'three/addons/controls/FlyControls.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffffff, 1, 29); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap; // Better soft shadows
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5;
        document.body.appendChild(renderer.domElement);

        // --- 2. ENVIRONMENT (SKY & WATER) ---
        
        // A. SKY
        const sky = new Sky();
        sky.scale.setScalar(450000);

        // Enlarge the sun
        const sunSize = 0.998; 
        sky.material.fragmentShader = sky.material.fragmentShader.replace(
            'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',
            `const float sunAngularDiameterCos = ${sunSize};`
        );

        scene.add(sky);
        
        const sunPosition = new THREE.Vector3();
        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 3;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.7;

        // B. WATER (Procedural)
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000, 128, 128);
        
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            roughness: 0.1,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        const waterUniforms = {
            uTime: { value: 0 },
            uStrength: { value: 1.0 } 
        };

        waterMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = waterUniforms.uTime;
            shader.uniforms.uStrength = waterUniforms.uStrength;
            
            shader.vertexShader = `
                uniform float uTime;
                uniform float uStrength;
                
                float calculateSurface(float x, float z) {
                    float y = 0.0;
                    y += (sin(x * 0.01 + uTime * 1.0) + sin(z * 0.01 + uTime * 0.5)) * 5.0;
                    y += (sin(x * 0.03 + uTime * 0.8) + sin(z * 0.03 + uTime * 1.2)) * 2.0;
                    return y * uStrength;
                }
            ` + shader.vertexShader;

            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                float rippleHeight = calculateSurface(position.x, position.y); 
                transformed.z += rippleHeight; 
                `
            );

            // Custom fog for water (distance 3000)
            shader.fragmentShader = shader.fragmentShader.replace(
                '#include <fog_fragment>',
                `
                #ifdef USE_FOG
                  #ifdef FOG_EXP2
                    float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
                  #else
                    float fogFactor = smoothstep( fogNear, 1700.0, vFogDepth );
                  #endif
                  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
                #endif
                `
            );
        };

        const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
        waterMesh.rotation.x = -Math.PI / 2; 
        waterMesh.position.y = -50; 
        waterMesh.receiveShadow = true;
        scene.add(waterMesh);

        // --- 3. LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemiLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        dirLight.castShadow = true; 
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.near = 0.1;
        dirLight.shadow.camera.far = 2000; // Increased to cover moon distance
        dirLight.shadow.mapSize.width = 4096; 
        dirLight.shadow.mapSize.height = 4096;
        dirLight.shadow.bias = -0.0001; 
        dirLight.shadow.blurSamples = 8;
        dirLight.shadow.radius = 4;
        scene.add(dirLight);

        // --- NIGHT MODE STATE ---
        let isNight = false; // Target state
        let nightFactor = 0.0; // Current transition value (0.0 = Day, 1.0 = Night)
        
        const nightLight = new THREE.PointLight(0xdb7e0b, 0, 100); // Start intensity 0
        nightLight.castShadow = true;
        scene.add(nightLight);
        nightLight.position.set(0, -7, -1.5);
        nightLight.visible = true;

        // Transition Colors/Values
        const fogColorDay = new THREE.Color(0xffffff);
        const fogColorNight = new THREE.Color(0x084566);
        const hemiColorDay = new THREE.Color(0xffffff);
        const hemiColorNight = new THREE.Color(0x666699);
        const dirColorDay = new THREE.Color(0xffffff);
        const dirColorNight = new THREE.Color(0x615c12);
        const moonPos = new THREE.Vector3(0, 200, -500);
        const bgNight = new THREE.Color(0x061b59);

        // --- FIREFLIES ---
        function getFireflyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        const maxFireflies = 500;
        const firefliesGeometry = new THREE.BufferGeometry();
        const firefliesPos = new Float32Array(maxFireflies * 3);
        const firefliesColors = new Float32Array(maxFireflies * 3);
        
        const fireflyBoids = [];
        const baseColor = new THREE.Color(0xe68c17); // Bright Yellow

        for(let i = 0; i < maxFireflies; i++) {
            // Initialize Boid-like properties
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 20,
                (Math.random() - 0.5) * 50
            );
            const velocity = new THREE.Vector3().randomDirection().multiplyScalar(Math.random() * 0.5 + 0.5);
            
            fireflyBoids.push({
                position: position,
                velocity: velocity,
                acceleration: new THREE.Vector3(),
                maxForce: 0.05,
                maxSpeed: 2.0
            });

            firefliesPos[i*3] = position.x;
            firefliesPos[i*3+1] = position.y;
            firefliesPos[i*3+2] = position.z;

            firefliesColors[i*3] = baseColor.r;
            firefliesColors[i*3+1] = baseColor.g;
            firefliesColors[i*3+2] = baseColor.b;
        }
        
        firefliesGeometry.setAttribute('position', new THREE.BufferAttribute(firefliesPos, 3));
        firefliesGeometry.setAttribute('color', new THREE.BufferAttribute(firefliesColors, 3));

        const firefliesMaterial = new THREE.PointsMaterial({
            size: 0.1, // Smaller size
            map: getFireflyTexture(),
            vertexColors: true,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const fireflies = new THREE.Points(firefliesGeometry, firefliesMaterial);
        fireflies.visible = false; 
        scene.add(fireflies);

        // --- 4. ASSET LOADERS ---
        const mixers = []; 
        const fbxLoader = new FBXLoader();
        const texLoader = new THREE.TextureLoader();

        function loadAsset(folderPath, x, y, z, scale = 0.01, animSpeed = 1.0, rotationOffset = 0, onMaterialReady = null) {
            const wrapper = new THREE.Group();
            wrapper.position.set(x, y, z);
            wrapper.scale.set(scale, scale, scale); 
            scene.add(wrapper);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (model) => {
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({
                            map: albedoMap,
                            normalMap: normalMap,
                            roughness: 0.5,
                            metalness: 0.1,
                            skinning: true 
                        });

                        if (onMaterialReady) {
                            onMaterialReady(child.material);
                        }

                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.frustumCulled = false; 
                    }
                });
                if (model.animations && model.animations.length > 0) {
                    const mixer = new THREE.AnimationMixer(model);
                    mixer.clipAction(model.animations[0]).play();
                    mixer.timeScale = animSpeed;
                    mixers.push(mixer);
                }
                model.rotation.y = rotationOffset;
                wrapper.add(model);
            }, undefined, (err) => console.error(err));
            return wrapper;
        }

        // --- BOIDS SYSTEM ---
        const boids = [];
        
        class Boid {
            constructor(mesh) {
                this.mesh = mesh;
                this.position = mesh.position;
                this.velocity = new THREE.Vector3().randomDirection().multiplyScalar(Math.random() * 2 + 2);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.1;
                this.maxSpeed = 4.0;
            }

            update(boids) {
                this.flock(boids);
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.set(0, 0, 0);
                
                // Orientation
                const lookTarget = this.position.clone().add(this.velocity);
                this.mesh.lookAt(lookTarget);
                
                // Keep within bounds (simple cage around the whale)
                if (this.position.length() > 150) {
                    this.velocity.add(this.position.clone().multiplyScalar(-0.005));
                }
            }

            flock(boids) {
                let separation = new THREE.Vector3();
                let alignment = new THREE.Vector3();
                let cohesion = new THREE.Vector3();
                let count = 0;
                
                const perceptionRadius = 50;
                
                for (let other of boids) {
                    if (other === this) continue;
                    const d = this.position.distanceTo(other.position);
                    if (d < perceptionRadius) {
                        // Separation
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.divideScalar(d);
                        separation.add(diff);
                        
                        // Alignment
                        alignment.add(other.velocity);
                        
                        // Cohesion
                        cohesion.add(other.position);
                        
                        count++;
                    }
                }
                
                if (count > 0) {
                    separation.divideScalar(count);
                    separation.setLength(this.maxSpeed);
                    separation.sub(this.velocity);
                    separation.clampLength(0, this.maxForce);
                    
                    alignment.divideScalar(count);
                    alignment.setLength(this.maxSpeed);
                    alignment.sub(this.velocity);
                    alignment.clampLength(0, this.maxForce);
                    
                    cohesion.divideScalar(count);
                    cohesion.sub(this.position);
                    cohesion.setLength(this.maxSpeed);
                    cohesion.sub(this.velocity);
                    cohesion.clampLength(0, this.maxForce);
                }
                
                separation.multiplyScalar(1.5);
                alignment.multiplyScalar(1.0);
                cohesion.multiplyScalar(1.0);
                
                this.acceleration.add(separation);
                this.acceleration.add(alignment);
                this.acceleration.add(cohesion);
            }
        }

        function spawnBoidCluster(parentObject, folderPath, count, orbitRadius, scale, yOffset) {
            const rotatorGroup = new THREE.Group();
            rotatorGroup.position.y = yOffset;
            parentObject.add(rotatorGroup);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (baseModel) => {
                for (let i = 0; i < count; i++) {
                    const clone = SkeletonUtils.clone(baseModel);
                    // Random initial position
                    const theta = Math.random() * Math.PI * 2; 
                    const phi = Math.acos((Math.random() * 2) - 1); 
                    const r = Math.random() * 100; // Start closer for boids
                    clone.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                    
                    clone.scale.set(scale, scale, scale);
                    
                    clone.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: albedoMap,
                                normalMap: normalMap,
                                skinning: true
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; 
                        }
                    });

                    if (baseModel.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(clone);
                        const action = mixer.clipAction(baseModel.animations[0]);
                        mixer.timeScale = 0.5 + Math.random(); 
                        action.play();
                        mixers.push(mixer);
                    }
                    rotatorGroup.add(clone);
                    
                    // Add to boids
                    boids.push(new Boid(clone));
                }
            });
            return rotatorGroup;
        }

        function spawnOrbitCluster(parentObject, folderPath, count, orbitRadius, scale, yOffset) {
            const rotatorGroup = new THREE.Group();
            rotatorGroup.position.y = yOffset;
            parentObject.add(rotatorGroup);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (baseModel) => {
                for (let i = 0; i < count; i++) {
                    const clone = SkeletonUtils.clone(baseModel);
                    const theta = Math.random() * Math.PI * 2; 
                    const phi = Math.acos((Math.random() * 2) - 1); 
                    const r = 5 + (Math.random() * orbitRadius); 
                    clone.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                    clone.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    clone.scale.set(scale, scale, scale);
                    
                    clone.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: albedoMap,
                                normalMap: normalMap,
                                skinning: true
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; 
                        }
                    });

                    if (baseModel.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(clone);
                        const action = mixer.clipAction(baseModel.animations[0]);
                        mixer.timeScale = 0.5 + Math.random(); 
                        action.play();
                        mixers.push(mixer);
                    }
                    rotatorGroup.add(clone);
                }
            });
            return rotatorGroup;
        }

        // --- ASSETS ---
        let obj1 = loadAsset('meshes/obj0', 0, -2, 3, 0.01); 
        let obj2 = loadAsset('meshes/obj1', 0, -0.25, -7, 0.02);
        obj2.rotation.y = Math.PI/2;
        let obj3 = loadAsset('meshes/obj2', -2, -1, -7.5, 0.015);
        obj3.rotation.y = Math.PI/2;
        let obj4 = loadAsset('meshes/obj3', 4, -1.5, -7, 0.02);
        obj4.rotation.y = -Math.PI/2;
        let obj5 = loadAsset('meshes/obj4', 0, -3, 0, 0.01);
        let obj6 = loadAsset('meshes/obj5', 300, -40, -760, 0.5, 1.0, 0, (mat) => {
            mat.onBeforeCompile = (shader) => {
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <fog_fragment>',
                    `
                    #ifdef USE_FOG
                      #ifdef FOG_EXP2
                        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
                      #else
                        float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
                      #endif
                      
                      // Clamp fog to 50% max to keep object visible even at distance
                      fogFactor = min(fogFactor, 0.5);
                      
                      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
                    #endif
                    `
                );
            };
        });

        let animatedObj = loadAsset('meshes/aobj0', 0, 0, 0, 0.018, 0.5, Math.PI);
        
        // 1. Boid Cluster (Dynamic flocking)
        let boidCluster = spawnBoidCluster(animatedObj, 'meshes/aobj1', 15, 446, 0.029, 70);
        
        // 2. Orbit Cluster (Static rotation)
        let orbitCluster = spawnOrbitCluster(animatedObj, 'meshes/aobj1', 15, 446, 0.029, 70);

        const whaleStart = new THREE.Vector3(35, -6, -20); 
        const whaleEnd = new THREE.Vector3(-60, 10, -20); 
        const whaleDuration = 60; 

        // ===============================================
        // LOOP
        // ===============================================

        const flyControls = new FlyControls(camera, renderer.domElement);
        flyControls.movementSpeed = 5;
        flyControls.rollSpeed = Math.PI / 6;
        flyControls.autoForward = false;
        flyControls.dragToLook = false;

        const mouse = { x: 0, y: 0 };
        const maxRad = 5 * (Math.PI / 180);

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        let isFreeFly = false;
        window.addEventListener('keydown', (event) => {
            if (event.code === 'Tab') {
                event.preventDefault();
                isFreeFly = !isFreeFly;
                if (!isFreeFly) {
                    camera.position.set(0, 0, 0);
                    camera.rotation.set(0, 0, 0);
                }
            }
            if (event.code === 'Space') {
                isNight = !isNight;
                fireflies.visible = isNight;
                // Transition logic is handled in animate()
            }
        });

        const clock = new THREE.Clock(); 

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); 
            const elapsedTime = clock.getElapsedTime();

            // --- DAY/NIGHT TRANSITION ---
            // Lerp nightFactor towards target (0 or 1)
            const targetFactor = isNight ? 1.0 : 0.0;
            if (Math.abs(nightFactor - targetFactor) > 0.001) {
                const speed = 2.0; // Transition speed
                nightFactor += (targetFactor - nightFactor) * delta * speed;
                
                // Clamp
                if (isNight && nightFactor > 1.0) nightFactor = 1.0;
                if (!isNight && nightFactor < 0.0) nightFactor = 0.0;

                // 1. Fog
                scene.fog.color.lerpColors(fogColorDay, fogColorNight, nightFactor);
                scene.fog.near = THREE.MathUtils.lerp(1, 10, nightFactor);
                scene.fog.far = THREE.MathUtils.lerp(29, 20, nightFactor);
                
                // 2. Background
                if (nightFactor > 0.1) {
                    if (!scene.background) scene.background = new THREE.Color();
                    scene.background.copy(bgNight).multiplyScalar(nightFactor); // Simple fade in
                } else {
                    scene.background = null;
                }

                // 3. Lights
                hemiLight.color.lerpColors(hemiColorDay, hemiColorNight, nightFactor);
                hemiLight.intensity = THREE.MathUtils.lerp(0.6, 0.25, nightFactor);

                dirLight.color.lerpColors(dirColorDay, dirColorNight, nightFactor);
                dirLight.intensity = THREE.MathUtils.lerp(3, 1.5, nightFactor);
                
                nightLight.intensity = THREE.MathUtils.lerp(0, 500, nightFactor);

                // 4. Sky
                sky.material.uniforms['rayleigh'].value = THREE.MathUtils.lerp(3, 0.1, nightFactor);
                sky.material.uniforms['turbidity'].value = THREE.MathUtils.lerp(10, 1, nightFactor);
            }

            // UPDATE WATER UNIFORMS
            waterUniforms.uTime.value = elapsedTime;

            // SUN/MOON POSITION
            // Calculate Day Position (Orbit)
            // Cycle between 30 and 70
            const minVal = 30;
            const maxVal = 70;
            const range = maxVal - minVal;
            const speed = 10; 
            const progress = minVal + (elapsedTime * speed) % range;
            const sunTheta = (progress / 100) * Math.PI * 2; 
            const sunPhi = THREE.MathUtils.degToRad(60); 
            
            const currentSunPos = new THREE.Vector3();
            currentSunPos.setFromSphericalCoords(100, sunPhi, sunTheta);
            
            // Lerp between Sun Pos and Moon Pos
            dirLight.position.lerpVectors(currentSunPos, moonPos, nightFactor);
            sky.material.uniforms['sunPosition'].value.copy(dirLight.position);


            for (const mixer of mixers) mixer.update(delta);

            const whaleProgress = (elapsedTime % whaleDuration) / whaleDuration;
            animatedObj.position.lerpVectors(whaleStart, whaleEnd, whaleProgress);
            animatedObj.lookAt(whaleEnd); 

            // Update Boids
            for (let boid of boids) {
                boid.update(boids);
            }

            // Update Fireflies (Boids Logic)
            if (isNight) {
                const sizeVal = 0.3;
                const countVal = 250;
                
                fireflies.material.size = sizeVal;
                fireflies.geometry.setDrawRange(0, countVal);

                const positions = fireflies.geometry.attributes.position.array;
                const perceptionRadius = 10;
                const separationDist = 5; // Increased separation distance

                // Only update active fireflies
                for(let i = 0; i < countVal; i++) {
                    const boid = fireflyBoids[i];
                    
                    let separation = new THREE.Vector3();
                    let alignment = new THREE.Vector3();
                    let cohesion = new THREE.Vector3();
                    let count = 0;

                    // Flocking - only check against other active fireflies
                    for(let j = 0; j < countVal; j++) {
                        if (i === j) continue;
                        const other = fireflyBoids[j];
                        const d = boid.position.distanceTo(other.position);
                        
                        if (d < perceptionRadius) {
                            // Separation
                            if (d < separationDist) {
                                let diff = new THREE.Vector3().subVectors(boid.position, other.position);
                                diff.divideScalar(d);
                                separation.add(diff);
                            }
                            // Alignment
                            alignment.add(other.velocity);
                            // Cohesion
                            cohesion.add(other.position);
                            count++;
                        }
                    }

                    if (count > 0) {
                        separation.divideScalar(count).setLength(boid.maxSpeed).sub(boid.velocity).clampLength(0, boid.maxForce);
                        alignment.divideScalar(count).setLength(boid.maxSpeed).sub(boid.velocity).clampLength(0, boid.maxForce);
                        cohesion.divideScalar(count).sub(boid.position).setLength(boid.maxSpeed).sub(boid.velocity).clampLength(0, boid.maxForce);
                    }

                    // Center Attraction (Keep them around camera)
                    const center = camera.position;
                    const distToCenter = boid.position.distanceTo(center);
                    const maxDist = 20; // Fixed radius for now
                    
                    if (distToCenter > maxDist) {
                        const toCenter = new THREE.Vector3().subVectors(center, boid.position).normalize().multiplyScalar(0.05);
                        boid.acceleration.add(toCenter);
                    }

                    // Orbit/Swirl around camera
                    const toBoid = new THREE.Vector3().subVectors(boid.position, center);
                    const orbitDir = new THREE.Vector3(-toBoid.z, 0, toBoid.x).normalize(); // Tangent
                    boid.acceleration.add(orbitDir.multiplyScalar(0.02));

                    boid.acceleration.add(separation.multiplyScalar(3.0)); // Increased separation force
                    boid.acceleration.add(alignment.multiplyScalar(1.0));
                    boid.acceleration.add(cohesion.multiplyScalar(1.0));

                    // Update Physics
                    boid.velocity.add(boid.acceleration);
                    boid.velocity.clampLength(0, boid.maxSpeed);
                    boid.position.add(new THREE.Vector3().copy(boid.velocity).multiplyScalar(delta * 10)); // Speed up slightly
                    boid.acceleration.set(0, 0, 0);

                    // Update Geometry
                    positions[i*3] = boid.position.x;
                    positions[i*3+1] = boid.position.y;
                    positions[i*3+2] = boid.position.z;
                }
                fireflies.geometry.attributes.position.needsUpdate = true;
            }

            // Update Orbit Cluster
            if(orbitCluster) {
                orbitCluster.rotation.y += 0.5 * delta; 
                orbitCluster.rotation.z += 0.2 * delta; 
            }

            if (isFreeFly) {
                flyControls.update(delta);
            } else {
                camera.rotation.x += ((mouse.y * maxRad) - camera.rotation.x) * 0.05;
                camera.rotation.y += ((-mouse.x * maxRad) - camera.rotation.y) * 0.05;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
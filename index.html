<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Final Whale Scene (Clean)</title>
    <style> 
        body { margin: 0; overflow: hidden; background: #87CEEB; } 
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { FlyControls } from 'three/addons/controls/FlyControls.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffffff, 1, 29); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5;
        document.body.appendChild(renderer.domElement);

        // --- 2. ENVIRONMENT (SKY & WATER) ---
        
        // A. SKY
        const sky = new Sky();
        sky.scale.setScalar(450000);

        // Enlarge the sun
        const sunSize = 0.998; 
        sky.material.fragmentShader = sky.material.fragmentShader.replace(
            'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',
            `const float sunAngularDiameterCos = ${sunSize};`
        );

        scene.add(sky);
        
        const sunPosition = new THREE.Vector3();
        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 3;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.7;

        // B. WATER (Procedural)
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000, 128, 128);
        
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            roughness: 0.1,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        const waterUniforms = {
            uTime: { value: 0 },
            uStrength: { value: 1.0 } 
        };

        waterMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = waterUniforms.uTime;
            shader.uniforms.uStrength = waterUniforms.uStrength;
            
            shader.vertexShader = `
                uniform float uTime;
                uniform float uStrength;
                
                float calculateSurface(float x, float z) {
                    float y = 0.0;
                    y += (sin(x * 0.01 + uTime * 1.0) + sin(z * 0.01 + uTime * 0.5)) * 5.0;
                    y += (sin(x * 0.03 + uTime * 0.8) + sin(z * 0.03 + uTime * 1.2)) * 2.0;
                    return y * uStrength;
                }
            ` + shader.vertexShader;

            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                float rippleHeight = calculateSurface(position.x, position.y); 
                transformed.z += rippleHeight; 
                `
            );

            // Custom fog for water (distance 3000)
            shader.fragmentShader = shader.fragmentShader.replace(
                '#include <fog_fragment>',
                `
                #ifdef USE_FOG
                  #ifdef FOG_EXP2
                    float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
                  #else
                    float fogFactor = smoothstep( fogNear, 1700.0, vFogDepth );
                  #endif
                  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
                #endif
                `
            );
        };

        const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
        waterMesh.rotation.x = -Math.PI / 2; 
        waterMesh.position.y = -50; 
        waterMesh.receiveShadow = true;
        scene.add(waterMesh);

        // --- 3. LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemiLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        dirLight.castShadow = true; 
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 1000;
        dirLight.shadow.mapSize.width = 2048; 
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);
        dirLight.shadow.bias = -0.0005; // <--- ADD THIS

        // --- 4. ASSET LOADERS ---
        const mixers = []; 
        const fbxLoader = new FBXLoader();
        const texLoader = new THREE.TextureLoader();

        function loadAsset(folderPath, x, y, z, scale = 0.01, animSpeed = 1.0, rotationOffset = 0, onMaterialReady = null) {
            const wrapper = new THREE.Group();
            wrapper.position.set(x, y, z);
            wrapper.scale.set(scale, scale, scale); 
            scene.add(wrapper);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (model) => {
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({
                            map: albedoMap,
                            normalMap: normalMap,
                            roughness: 0.5,
                            metalness: 0.1,
                            skinning: true 
                        });

                        if (onMaterialReady) {
                            onMaterialReady(child.material);
                        }

                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.frustumCulled = false; 
                    }
                });
                if (model.animations && model.animations.length > 0) {
                    const mixer = new THREE.AnimationMixer(model);
                    mixer.clipAction(model.animations[0]).play();
                    mixer.timeScale = animSpeed;
                    mixers.push(mixer);
                }
                model.rotation.y = rotationOffset;
                wrapper.add(model);
            }, undefined, (err) => console.error(err));
            return wrapper;
        }

        // --- BOIDS SYSTEM ---
        const boids = [];
        
        class Boid {
            constructor(mesh) {
                this.mesh = mesh;
                this.position = mesh.position;
                this.velocity = new THREE.Vector3().randomDirection().multiplyScalar(Math.random() * 2 + 2);
                this.acceleration = new THREE.Vector3();
                this.maxForce = 0.1;
                this.maxSpeed = 4.0;
            }

            update(boids) {
                this.flock(boids);
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.set(0, 0, 0);
                
                // Orientation
                const lookTarget = this.position.clone().add(this.velocity);
                this.mesh.lookAt(lookTarget);
                
                // Keep within bounds (simple cage around the whale)
                if (this.position.length() > 150) {
                    this.velocity.add(this.position.clone().multiplyScalar(-0.005));
                }
            }

            flock(boids) {
                let separation = new THREE.Vector3();
                let alignment = new THREE.Vector3();
                let cohesion = new THREE.Vector3();
                let count = 0;
                
                const perceptionRadius = 50;
                
                for (let other of boids) {
                    if (other === this) continue;
                    const d = this.position.distanceTo(other.position);
                    if (d < perceptionRadius) {
                        // Separation
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.divideScalar(d);
                        separation.add(diff);
                        
                        // Alignment
                        alignment.add(other.velocity);
                        
                        // Cohesion
                        cohesion.add(other.position);
                        
                        count++;
                    }
                }
                
                if (count > 0) {
                    separation.divideScalar(count);
                    separation.setLength(this.maxSpeed);
                    separation.sub(this.velocity);
                    separation.clampLength(0, this.maxForce);
                    
                    alignment.divideScalar(count);
                    alignment.setLength(this.maxSpeed);
                    alignment.sub(this.velocity);
                    alignment.clampLength(0, this.maxForce);
                    
                    cohesion.divideScalar(count);
                    cohesion.sub(this.position);
                    cohesion.setLength(this.maxSpeed);
                    cohesion.sub(this.velocity);
                    cohesion.clampLength(0, this.maxForce);
                }
                
                separation.multiplyScalar(1.5);
                alignment.multiplyScalar(1.0);
                cohesion.multiplyScalar(1.0);
                
                this.acceleration.add(separation);
                this.acceleration.add(alignment);
                this.acceleration.add(cohesion);
            }
        }

        function spawnBoidCluster(parentObject, folderPath, count, orbitRadius, scale, yOffset) {
            const rotatorGroup = new THREE.Group();
            rotatorGroup.position.y = yOffset;
            parentObject.add(rotatorGroup);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (baseModel) => {
                for (let i = 0; i < count; i++) {
                    const clone = SkeletonUtils.clone(baseModel);
                    // Random initial position
                    const theta = Math.random() * Math.PI * 2; 
                    const phi = Math.acos((Math.random() * 2) - 1); 
                    const r = Math.random() * 100; // Start closer for boids
                    clone.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                    
                    clone.scale.set(scale, scale, scale);
                    
                    clone.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: albedoMap,
                                normalMap: normalMap,
                                skinning: true
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; 
                        }
                    });

                    if (baseModel.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(clone);
                        const action = mixer.clipAction(baseModel.animations[0]);
                        mixer.timeScale = 0.5 + Math.random(); 
                        action.play();
                        mixers.push(mixer);
                    }
                    rotatorGroup.add(clone);
                    
                    // Add to boids
                    boids.push(new Boid(clone));
                }
            });
            return rotatorGroup;
        }

        function spawnOrbitCluster(parentObject, folderPath, count, orbitRadius, scale, yOffset) {
            const rotatorGroup = new THREE.Group();
            rotatorGroup.position.y = yOffset;
            parentObject.add(rotatorGroup);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (baseModel) => {
                for (let i = 0; i < count; i++) {
                    const clone = SkeletonUtils.clone(baseModel);
                    const theta = Math.random() * Math.PI * 2; 
                    const phi = Math.acos((Math.random() * 2) - 1); 
                    const r = 5 + (Math.random() * orbitRadius); 
                    clone.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                    clone.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    clone.scale.set(scale, scale, scale);
                    
                    clone.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: albedoMap,
                                normalMap: normalMap,
                                skinning: true
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; 
                        }
                    });

                    if (baseModel.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(clone);
                        const action = mixer.clipAction(baseModel.animations[0]);
                        mixer.timeScale = 0.5 + Math.random(); 
                        action.play();
                        mixers.push(mixer);
                    }
                    rotatorGroup.add(clone);
                }
            });
            return rotatorGroup;
        }

        // --- ASSETS ---
        let obj1 = loadAsset('meshes/obj0', 0, -2, 3, 0.01); 
        let obj2 = loadAsset('meshes/obj1', 0, -0.25, -7, 0.02);
        obj2.rotation.y = Math.PI/2;
        let obj3 = loadAsset('meshes/obj2', -2, -1, -7.5, 0.015);
        obj3.rotation.y = Math.PI/2;
        let obj4 = loadAsset('meshes/obj3', 4, -1.5, -7, 0.02);
        obj4.rotation.y = -Math.PI/2;
        let obj5 = loadAsset('meshes/obj4', 0, -3, 0, 0.01);
        let obj6 = loadAsset('meshes/obj5', 300, -50, -560, 0.3, 1.0, 0, (mat) => {
            mat.onBeforeCompile = (shader) => {
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <fog_fragment>',
                    `
                    #ifdef USE_FOG
                      #ifdef FOG_EXP2
                        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
                      #else
                        float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
                      #endif
                      
                      // Clamp fog to 50% max to keep object visible even at distance
                      fogFactor = min(fogFactor, 0.5);
                      
                      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
                    #endif
                    `
                );
            };
        });

        let animatedObj = loadAsset('meshes/aobj0', 0, 0, 0, 0.018, 0.5, Math.PI);
        
        // 1. Boid Cluster (Dynamic flocking)
        let boidCluster = spawnBoidCluster(animatedObj, 'meshes/aobj1', 15, 446, 0.029, 70);
        
        // 2. Orbit Cluster (Static rotation)
        let orbitCluster = spawnOrbitCluster(animatedObj, 'meshes/aobj1', 15, 446, 0.029, 70);

        const whaleStart = new THREE.Vector3(35, -6, -20); 
        const whaleEnd = new THREE.Vector3(-60, 10, -20); 
        const whaleDuration = 60; 

        // ===============================================
        // LOOP
        // ===============================================

        const flyControls = new FlyControls(camera, renderer.domElement);
        flyControls.movementSpeed = 5;
        flyControls.rollSpeed = Math.PI / 6;
        flyControls.autoForward = false;
        flyControls.dragToLook = false;

        const mouse = { x: 0, y: 0 };
        const maxRad = 5 * (Math.PI / 180);

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        let isFreeFly = false;
        window.addEventListener('keydown', (event) => {
            if (event.code === 'Tab') {
                event.preventDefault();
                isFreeFly = !isFreeFly;
                if (!isFreeFly) {
                    camera.position.set(0, 0, 0);
                    camera.rotation.set(0, 0, 0);
                }
            }
        });

        const clock = new THREE.Clock(); 

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); 
            const elapsedTime = clock.getElapsedTime();

            // UPDATE WATER UNIFORMS
            waterUniforms.uTime.value = elapsedTime;

            // SUN ORBIT
            const sunTheta = 100 * 0.1; 
            const sunPhi = THREE.MathUtils.degToRad(60); 
            sunPosition.setFromSphericalCoords(100, sunPhi, sunTheta);
            sky.material.uniforms['sunPosition'].value.copy(sunPosition);
            dirLight.position.copy(sunPosition);

            for (const mixer of mixers) mixer.update(delta);

            const whaleProgress = (elapsedTime % whaleDuration) / whaleDuration;
            animatedObj.position.lerpVectors(whaleStart, whaleEnd, whaleProgress);
            animatedObj.lookAt(whaleEnd); 

            // Update Boids
            for (let boid of boids) {
                boid.update(boids);
            }

            // Update Orbit Cluster
            if(orbitCluster) {
                orbitCluster.rotation.y += 0.5 * delta; 
                orbitCluster.rotation.z += 0.2 * delta; 
            }

            if (isFreeFly) {
                flyControls.update(delta);
            } else {
                camera.rotation.x += ((mouse.y * maxRad) - camera.rotation.x) * 0.05;
                camera.rotation.y += ((-mouse.x * maxRad) - camera.rotation.y) * 0.05;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
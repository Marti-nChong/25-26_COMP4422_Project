<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Final Whale Scene (Clean)</title>
    <style> 
        body { margin: 0; overflow: hidden; background: #87CEEB; } 
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { FlyControls } from 'three/addons/controls/FlyControls.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xffffff, 1, 3000); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.5;
        document.body.appendChild(renderer.domElement);

        // --- 2. ENVIRONMENT (SKY & WATER) ---
        
        // A. SKY
        const sky = new Sky();
        sky.scale.setScalar(450000);
        scene.add(sky);
        
        const sunPosition = new THREE.Vector3();
        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 10;
        skyUniforms['rayleigh'].value = 3;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.7;

        // B. WATER (Procedural)
        const waterGeometry = new THREE.PlaneGeometry(10000, 10000, 128, 128);
        
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x006994,
            roughness: 0.1,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        const waterUniforms = {
            uTime: { value: 0 },
            uStrength: { value: 1.0 } 
        };

        waterMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.uTime = waterUniforms.uTime;
            shader.uniforms.uStrength = waterUniforms.uStrength;
            
            shader.vertexShader = `
                uniform float uTime;
                uniform float uStrength;
                
                float calculateSurface(float x, float z) {
                    float y = 0.0;
                    y += (sin(x * 0.01 + uTime * 1.0) + sin(z * 0.01 + uTime * 0.5)) * 5.0;
                    y += (sin(x * 0.03 + uTime * 0.8) + sin(z * 0.03 + uTime * 1.2)) * 2.0;
                    return y * uStrength;
                }
            ` + shader.vertexShader;

            shader.vertexShader = shader.vertexShader.replace(
                '#include <begin_vertex>',
                `
                #include <begin_vertex>
                float rippleHeight = calculateSurface(position.x, position.y); 
                transformed.z += rippleHeight; 
                `
            );
        };

        const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
        waterMesh.rotation.x = -Math.PI / 2; 
        waterMesh.position.y = -50; 
        waterMesh.receiveShadow = true;
        scene.add(waterMesh);

        // --- 3. LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemiLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        dirLight.castShadow = true; 
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 1000;
        dirLight.shadow.mapSize.width = 2048; 
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- 4. ASSET LOADERS ---
        const mixers = []; 
        const fbxLoader = new FBXLoader();
        const texLoader = new THREE.TextureLoader();

        function loadAsset(folderPath, x, y, z, scale = 0.01, animSpeed = 1.0, rotationOffset = 0) {
            const wrapper = new THREE.Group();
            wrapper.position.set(x, y, z);
            wrapper.scale.set(scale, scale, scale); 
            scene.add(wrapper);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (model) => {
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({
                            map: albedoMap,
                            normalMap: normalMap,
                            roughness: 0.5,
                            metalness: 0.1,
                            skinning: true 
                        });
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.frustumCulled = false; 
                    }
                });
                if (model.animations && model.animations.length > 0) {
                    const mixer = new THREE.AnimationMixer(model);
                    mixer.clipAction(model.animations[0]).play();
                    mixer.timeScale = animSpeed;
                    mixers.push(mixer);
                }
                model.rotation.y = rotationOffset;
                wrapper.add(model);
            }, undefined, (err) => console.error(err));
            return wrapper;
        }

        function spawnCluster(parentObject, folderPath, count, orbitRadius, scale, yOffset) {
            const rotatorGroup = new THREE.Group();
            rotatorGroup.position.y = yOffset;
            parentObject.add(rotatorGroup);

            const path = folderPath.endsWith('/') ? folderPath : folderPath + '/';
            const albedoMap = texLoader.load(path + 'albedo.png');
            const normalMap = texLoader.load(path + 'normal.png');
            albedoMap.colorSpace = THREE.SRGBColorSpace;

            fbxLoader.load(path + 'object.fbx', (baseModel) => {
                for (let i = 0; i < count; i++) {
                    const clone = SkeletonUtils.clone(baseModel);
                    const theta = Math.random() * Math.PI * 2; 
                    const phi = Math.acos((Math.random() * 2) - 1); 
                    const r = 5 + (Math.random() * orbitRadius); 
                    clone.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
                    clone.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    clone.scale.set(scale, scale, scale);
                    
                    clone.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: albedoMap,
                                normalMap: normalMap,
                                skinning: true
                            });
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.frustumCulled = false; 
                        }
                    });

                    if (baseModel.animations.length > 0) {
                        const mixer = new THREE.AnimationMixer(clone);
                        const action = mixer.clipAction(baseModel.animations[0]);
                        mixer.timeScale = 0.5 + Math.random(); 
                        action.play();
                        mixers.push(mixer);
                    }
                    rotatorGroup.add(clone);
                }
            });
            return rotatorGroup;
        }

        // --- ASSETS ---
        let obj1 = loadAsset('meshes/obj0', 0, -2, 3, 0.01); 
        let obj2 = loadAsset('meshes/obj1', 0, -0.25, -7, 0.02);
        obj2.rotation.y = Math.PI/2;
        let obj3 = loadAsset('meshes/obj2', -2, -1, -7.5, 0.015);
        obj3.rotation.y = Math.PI/2;
        let obj4 = loadAsset('meshes/obj3', 4, -1.5, -7, 0.02);
        obj4.rotation.y = -Math.PI/2;
        let obj5 = loadAsset('meshes/obj4', 0, -3, -5, 0.01);

        let animatedObj = loadAsset('meshes/aobj0', 0, 0, 0, 0.018, 0.5, Math.PI);
        let clusterRotator = spawnCluster(animatedObj, 'meshes/aobj1', 30, 446, 0.029, 70);

        const whaleStart = new THREE.Vector3(35, -6, -20); 
        const whaleEnd = new THREE.Vector3(-60, 10, -20); 
        const whaleDuration = 60; 

        // ===============================================
        // LOOP
        // ===============================================

        const flyControls = new FlyControls(camera, renderer.domElement);
        flyControls.movementSpeed = 5;
        flyControls.rollSpeed = Math.PI / 6;
        flyControls.autoForward = false;
        flyControls.dragToLook = false;

        const mouse = { x: 0, y: 0 };
        const maxRad = 5 * (Math.PI / 180);

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        let isFreeFly = false;
        window.addEventListener('keydown', (event) => {
            if (event.code === 'Tab') {
                event.preventDefault();
                isFreeFly = !isFreeFly;
                if (!isFreeFly) {
                    camera.position.set(0, 0, 0);
                    camera.rotation.set(0, 0, 0);
                }
            }
        });

        const clock = new THREE.Clock(); 

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); 
            const elapsedTime = clock.getElapsedTime();

            // UPDATE WATER UNIFORMS
            waterUniforms.uTime.value = elapsedTime;

            // SUN ORBIT
            const sunTheta = elapsedTime * 0.1; 
            const sunPhi = THREE.MathUtils.degToRad(60); 
            sunPosition.setFromSphericalCoords(100, sunPhi, sunTheta);
            sky.material.uniforms['sunPosition'].value.copy(sunPosition);
            dirLight.position.copy(sunPosition);

            for (const mixer of mixers) mixer.update(delta);

            const whaleProgress = (elapsedTime % whaleDuration) / whaleDuration;
            animatedObj.position.lerpVectors(whaleStart, whaleEnd, whaleProgress);
            animatedObj.lookAt(whaleEnd); 

            if(clusterRotator) {
                clusterRotator.rotation.y += 0.5 * delta; 
                clusterRotator.rotation.z += 0.2 * delta; 
            }

            if (isFreeFly) {
                flyControls.update(delta);
            } else {
                camera.rotation.x += ((mouse.y * maxRad) - camera.rotation.x) * 0.05;
                camera.rotation.y += ((-mouse.x * maxRad) - camera.rotation.y) * 0.05;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
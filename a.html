<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Skybox - Fixed Stars</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui {
            position: absolute;
            top: 10px; left: 10px;
            color: white; font-family: monospace;
            background: rgba(0,0,0,0.6); padding: 15px;
            pointer-events: none; user-select: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <b>Controls:</b><br>
        Click to Capture Mouse<br>
        [W, A, S, D] to Move<br>
        [Mouse] to Look<br>
    </div>
    <canvas id="glcanvas"></canvas>

    <!-- VERTEX SHADER -->
    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <!-- FRAGMENT SHADER -->
    <script id="fs" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 uResolution;
        uniform float uTime;
        
        uniform vec3 uCamPos;
        uniform vec3 uCamFwd;
        uniform vec3 uCamRight;
        uniform vec3 uCamUp;

        // Random Noise Generator
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
            // 1. Setup Screen Coordinates
            vec2 uv = gl_FragCoord.xy / uResolution.xy;
            vec2 p = uv * 2.0 - 1.0;
            p.x *= uResolution.x / uResolution.y;

            // 2. Create Ray Direction (World Space)
            vec3 rayDir = normalize(p.x * uCamRight + p.y * uCamUp + 2.0 * uCamFwd);

            // 3. Sun Logic
            float speed = 0.1; 
            float t = uTime * speed;
            vec3 sunPos = normalize(vec3(sin(t), sin(t)*0.8, cos(t)));
            float sunDot = dot(rayDir, sunPos);
            float sunHeight = sunPos.y;
            float dayFactor = smoothstep(-0.2, 0.2, sunHeight);

            // 4. Sky Colors
            vec3 blueSky = vec3(0.3, 0.5, 0.9);
            vec3 sunsetSky = vec3(1.0, 0.6, 0.3);
            vec3 nightSky = vec3(0.05, 0.05, 0.1);
            vec3 horizonColor = vec3(0.8, 0.9, 1.0);

            float horizonBlend = pow(1.0 - max(rayDir.y, 0.0), 4.0);

            vec3 dayGradient = mix(blueSky, horizonColor, horizonBlend);
            float sunsetFactor = pow(1.0 - abs(sunHeight), 4.0);
            dayGradient = mix(dayGradient, sunsetSky, sunsetFactor * 0.8);
            vec3 nightGradient = mix(nightSky, vec3(0.0), horizonBlend);
            
            vec3 finalColor = mix(nightGradient, dayGradient, dayFactor);

            // --- 5. FIXED STARS LOGIC ---
            // Previously we used gl_FragCoord (screen pixel).
            // Now we convert the 3D Ray Direction to Spherical Coordinates (Angles).
            // This ensures the texture maps to the "Sky Sphere", not the monitor.
            
            // atan(z, x) gets the horizontal angle (Yaw)
            // acos(y) gets the vertical angle (Pitch)
            vec2 skyUV = vec2(atan(rayDir.z, rayDir.x), asin(rayDir.y));
            
            // Scale coordinates up to get smaller/more noise pattern
            // Multiplied by 30.0 to create density
            float starVal = random(skyUV * 30.0); 
            
            // Only draw stars above horizon
            if (starVal > 0.995 && rayDir.y > 0.0) {
                // Twinkle logic
                float twinkle = 0.5 + 0.5 * sin(uTime * 4.0 + starVal * 100.0);
                
                // Add stars (masked by night)
                finalColor += vec3(twinkle) * (1.0 - dayFactor);
            }

            // 6. Sun Render
            float sunRadius = 0.04;
            if (sunDot > (1.0 - sunRadius * 0.1)) {
                finalColor = mix(vec3(1.0, 0.5, 0.0), vec3(1.0), smoothstep(-0.1, 0.5, sunHeight));
            }
            finalColor += vec3(1.0, 0.8, 0.5) * pow(max(sunDot, 0.0), 64.0) * 0.5;

            // 7. Procedural Floor
            if (rayDir.y < -0.001) {
                float tDist = (-2.0 - uCamPos.y) / rayDir.y;
                if (tDist > 0.0) {
                    vec3 hitPos = uCamPos + rayDir * tDist;
                    float checkSize = 2.0;
                    float checker = mod(floor(hitPos.x/checkSize) + floor(hitPos.z/checkSize), 2.0);
                    vec3 groundColor = mix(vec3(0.1), vec3(0.2), checker) * dayFactor;
                    float fog = smoothstep(10.0, 100.0, length(hitPos - uCamPos));
                    finalColor = mix(groundColor, finalColor, fog);
                }
            }

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) alert("WebGL not supported");

        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, document.getElementById('vs').text);
        gl.compileShader(vs);

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, document.getElementById('fs').text);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(fs));
        gl.compileShader(fs);

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        gl.useProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        const posLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const locRes = gl.getUniformLocation(program, "uResolution");
        const locTime = gl.getUniformLocation(program, "uTime");
        const locCamPos = gl.getUniformLocation(program, "uCamPos");
        const locCamFwd = gl.getUniformLocation(program, "uCamFwd");
        const locCamRight = gl.getUniformLocation(program, "uCamRight");
        const locCamUp = gl.getUniformLocation(program, "uCamUp");

        const camera = { x: 0, y: 0, z: 0, yaw: 0, pitch: 0, speed: 10.0 };
        const keys = {};

        canvas.addEventListener('click', () => canvas.requestPointerLock());
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === canvas) {
                camera.yaw += e.movementX * 0.002;
                camera.pitch -= e.movementY * 0.002;
                camera.pitch = Math.max(-1.5, Math.min(1.5, camera.pitch));
            }
        });
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function getCameraVectors() {
            const cosP = Math.cos(camera.pitch);
            const fwd = {
                x: Math.sin(camera.yaw) * cosP,
                y: Math.sin(camera.pitch),
                z: Math.cos(camera.yaw) * cosP
            };
            let right = { x: -fwd.z, y: 0, z: fwd.x };
            let len = Math.sqrt(right.x*right.x + right.z*right.z);
            right.x /= len; right.z /= len;
            const up = {
                x: right.y*fwd.z - right.z*fwd.y,
                y: right.z*fwd.x - right.x*fwd.z,
                z: right.x*fwd.y - right.y*fwd.x
            };
            return { fwd, right, up };
        }

        let lastTime = 0;
        function loop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            const { fwd, right, up } = getCameraVectors();
            const moveSpeed = camera.speed * dt;

            if (keys.w) { camera.x += fwd.x * moveSpeed; camera.z += fwd.z * moveSpeed; }
            if (keys.s) { camera.x -= fwd.x * moveSpeed; camera.z -= fwd.z * moveSpeed; }
            if (keys.a) { camera.x -= right.x * moveSpeed; camera.z -= right.z * moveSpeed; }
            if (keys.d) { camera.x += right.x * moveSpeed; camera.z += right.z * moveSpeed; }

            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            gl.uniform2f(locRes, canvas.width, canvas.height);
            gl.uniform1f(locTime, timestamp * 0.001);
            gl.uniform3f(locCamPos, camera.x, camera.y, camera.z);
            gl.uniform3f(locCamFwd, fwd.x, fwd.y, fwd.z);
            gl.uniform3f(locCamRight, right.x, right.y, right.z);
            gl.uniform3f(locCamUp, up.x, up.y, up.z);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>
</html>
<!doctype html>
<html>
<head>
<title>Mesh Drawing</title>
	<style>
		body{ background-color: grey; }
		canvas{ background-color: white; }
	</style>

	<script src="libs/gl-matrix-min.js"></script>
	<script src="libs/webgl-obj-loader.js"></script>
	<script src="libs/transformation.js"></script>
	<script src="libs/noisejs-master/perlin.js"></script>
	<script src="libs/webgl-utils.js"></script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		uniform mat4 uVMatrix;
		uniform mat4 uPMatrix;
		uniform mat4 uLWMatrix;
		varying highp vec4 vColor;
		void main(void) {
			gl_Position = uPMatrix * uVMatrix * uLWMatrix * vec4(aVertexPosition, 1.0);
			vColor = vec4(1.0, 1.0, 1.0, 1.0);
		}
	</script>
	<script id="shader-fs" type="x-shader/x-fragment">
		varying highp vec4 vColor;
		void main(void) {
			gl_FragColor = vColor;
		}
	</script>
	<script id="shader-fs-red" type="x-shader/x-fragment">
		varying highp vec4 vColor;
		void main(void) {
			gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
		}
	</script>
		<script id="shader-vs-texture" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		attribute vec2 aTextureCoord;
		uniform mat4 uVMatrix;
		uniform mat4 uPMatrix;
		uniform mat4 uLWMatrix;
		varying vec2 vTextureCoord;
		void main(void) {
			gl_Position = uPMatrix * uVMatrix * uLWMatrix * vec4(aVertexPosition, 1.0);
			vTextureCoord = aTextureCoord;
		}
	</script>

	<script id="shader-fs-albedo" type="x-shader/x-fragment">
	    precision mediump float;
	    varying vec2 vTextureCoord;
	    uniform sampler2D uSampler; // base/albedo
	    void main(void) {
	        // Show normal map colors directly for debugging/visualisation.
	        // Samples come in [0,1] and represent tangent-space normals encoded
	        // as RGB; we simply output the sampled color.
			vec4 albedoColor = texture2D(uSampler, vTextureCoord);
	        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // Placeholder
			gl_FragColor = albedoColor;
	    }
	</script>

	<script id="shader-fs-texture" type="x-shader/x-fragment">
	    precision mediump float;
	    varying vec2 vTextureCoord;
	    uniform sampler2D uSampler; // base/albedo
	    uniform sampler2D uNormalSampler; // normal map (displayed directly)
	    void main(void) {
	        // Show normal map colors directly for debugging/visualisation.
	        // Samples come in [0,1] and represent tangent-space normals encoded
	        // as RGB; we simply output the sampled color.
			vec4 albedoColor = texture2D(uSampler, vTextureCoord);
	        vec4 normalColor = texture2D(uNormalSampler, vTextureCoord);
	        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); // Placeholder
			gl_FragColor = albedoColor;
	    }
	</script>
	<script id="shader-vs-lit" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec2 aTextureCoord;
		attribute vec3 aVertexTangent;
		uniform mat4 uVMatrix;
		uniform mat4 uPMatrix;
		uniform mat4 uLWMatrix;
		varying vec2 vTextureCoord;
		varying vec3 vVertexNormal;
		varying vec3 vTangent;
		varying vec3 vBitangent;

		void main(void) {
			gl_Position = uPMatrix * uVMatrix * uLWMatrix * vec4(aVertexPosition, 1.0);
			vTextureCoord = aTextureCoord;
			vVertexNormal = normalize(mat3(uLWMatrix) * aVertexNormal);
			vTangent = aVertexTangent;
		}
	</script>

	<script id="shader-fs-lit" type="x-shader/x-fragment">
	    precision mediump float;
		varying vec3 vVertexNormal;
	    varying vec2 vTextureCoord;
		varying vec3 vTangent;
		varying vec3 vBitangent;
	    uniform sampler2D uSampler; // base/albedo
	    uniform sampler2D uNormalSampler; // normal map (displayed directly)
	    void main(void) {
			vec4 albedoColor = texture2D(uSampler, vTextureCoord);
	        vec4 normalColor = texture2D(uNormalSampler, vTextureCoord);

			vec3 lightDir = normalize(vec3(1.0, 0.0, 0.0));
			vec3 normal = normalize(normalColor.xyz * 2.0 - 1.0);
			
			float lightIntensity = max(dot(vVertexNormal, lightDir), 0.0);
			gl_FragColor = vec4(albedoColor.rgb * lightIntensity, albedoColor.a);
			// gl_FragColor = vec4(normal, 1.0); // visualize normal map
		}
	</script>


	<script>
		let gl = null,
			canvas = null;

		let	vMatrix = mat4.create(),
			pMatrix = mat4.create();

		let rotateValue = 0.0;
		let mySceneObjects = [];

		// Read the mesh file as text
		let skullMeshStr = readTextFile("meshes/stool.obj");
		let cubeMeshStr = readTextFile("meshes/cube.obj");
		let dirtyCarStr = readTextFile("meshes/dirty-car/source/dirtyCar.obj");
		
		let myMeshObj = new my3DObject(dirtyCarStr);
		let myMeshObj2 = new my3DObject(skullMeshStr);
		myMeshObj.name = "object1";
		myMeshObj2.name = "object2";


		
		let mainDirectionLight = vec3.create();
		vec3.set([0.0, -1.0, 0.0], mainDirectionLight);

		console.log("Main light direction: " + mainDirectionLight);

		function initWebGL()
		{
			canvas = document.getElementById("my-canvas");
			gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

			canvas.onmousedown = function(e) {
				console.log("Mouse down at: " + e.clientX + ", " + e.clientY);
			};

			if(gl)
			{
				// enable depth testing for correct 3D rendering
				gl.enable(gl.DEPTH_TEST);
				gl.clearDepth(1.0);
				//get shader source
				let vs_source = document.getElementById('shader-vs-texture').innerHTML;
				let fs_source = document.getElementById('shader-fs-albedo').innerHTML;
				
				let vs_r_source = document.getElementById('shader-vs-lit').innerHTML;
				let fs_r_source = document.getElementById('shader-fs-lit').innerHTML;

				initMy3DObject(myMeshObj, vs_r_source, fs_r_source);
				initMy3DObject(myMeshObj2, vs_r_source, fs_r_source);
				loadTexture(myMeshObj, "meshes/dirty-car/textures/large_car_d.tga.png");
				loadNormalTexture(myMeshObj, "meshes/dirty-car/textures/large_car_ddna.tga.png");
				loadTexture(myMeshObj2, "meshes/textures/Material_albedo.jpeg");
				loadNormalTexture(myMeshObj2, "meshes/textures/Material_normal.png");

				mySceneObjects.push(myMeshObj);
				mySceneObjects.push(myMeshObj2);

				myMeshObj.toOrigin();
				myMeshObj2.toOrigin();
				
				scale = vec3.create();
				vec3.set([1.0, 1.0, 1.0], scale);
				vec3.scale(scale, 2.0, scale);
				console.log("Scale vector: " + scale);

				myMeshObj.translate(-4, -1, -1);
				myMeshObj.scale(scale[0], scale[1], scale[2]);
				myMeshObj2.translate(4, -1, -5);
				myMeshObj2.scale(scale[0], scale[1], scale[2]);
				animLoop();
			}else{
				alert( "Error: Your browser does not appear to" + "support WebGL.");
			}
		}

		function animLoop()
		{
			updateWebGL();
			updateBuffers();
			drawScene();
			requestAnimationFrame(animLoop, canvas);
		}

		function updateCamera(){
			
		}

		function updateWebGL()
		{
			//set the clear color to a shade of green
			gl.clearColor(0.4, 0.4, 0.4, 1.0);
			// clear color and depth buffers
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			//set viewport
			gl.viewport(0, 0, canvas.width, canvas.height);

			let timestamp = performance.now() / 1000;
			const frequency = 0.0;
			const sinValue = Math.sin(timestamp * frequency);

			updateCamera();
			//set view and projection matrix
			mat4.perspective(45, canvas.width / canvas.height, 0.1, 100.0, pMatrix);
			mat4.identity(vMatrix);
			mat4.translate(vMatrix, [0, 0, -10.0]);
			mat4.translate(vMatrix, [0, sinValue, 0]);

			let rotAxis = new Array(0,1,0);
			let rotateAngleMax = 45.0 * Math.PI / 180.0; // 45 degrees in radians
			let rotateAngle = rotateAngleMax * Math.sin(timestamp);
			// mat4.rotate(vMatrix, rotateAngle, rotAxis);

			myMeshObj.rotate(rotateValue, rotAxis);
			myMeshObj2.rotate(-rotateValue, rotAxis);

		}

		function initShaders(my3DObject, vs_source, fs_source)
		{

			//compile shaders
			// makeShader(code, type)
			vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
			fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
			
			// create, attach and link program
			let myglProgram = gl.createProgram();
			gl.attachShader(myglProgram, vertexShader);
			gl.attachShader(myglProgram, fragmentShader);
			gl.linkProgram(myglProgram);
			// support multiple common attribute names
			
			let posLoc = gl.getAttribLocation(myglProgram, "aVertexPosition");
			myglProgram.vertexPositionAttribute = posLoc;

			myglProgram.vertexNormalAttribute = gl.getAttribLocation(myglProgram, "aVertexNormal");
			myglProgram.textureCoordAttribute = gl.getAttribLocation(myglProgram, "aTextureCoord");
			myglProgram.vertexTangentAttribute = gl.getAttribLocation(myglProgram, "aVertexTangent");
			my3DObject.setProgram(myglProgram);

			if (!gl.getProgramParameter(myglProgram, gl.LINK_STATUS)) {
				alert("Unable to initialize the shader program (program 1).\n" + gl.getProgramInfoLog(myglProgram));
			}
		}

		function makeShader(src, type)
		{
			//compile the vertex shader
			let shader = gl.createShader(type);
			gl.shaderSource(shader, src);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
			}
			return shader;
		}

		function initBuffers(my3DObject)
		{
			// initialize WebGL buffers for the mesh (positions, indices, normals)
			OBJ.initMeshBuffers(gl, my3DObject.OBJ);
			console.log('initBuffers: mesh vertices=', my3DObject.OBJ.vertices ? my3DObject.OBJ.vertices.length : 0,
				'indices=', my3DObject.OBJ.indices ? my3DObject.OBJ.indices.length : 0,
				'vertexBuffer=', !!my3DObject.OBJ.vertexBuffer, 'indexBuffer=', !!my3DObject.OBJ.indexBuffer);
		}

		function loadTexture(my3DObject, src)
	    {
			let Myprogram = my3DObject.getProgram();
	        Myprogram.texture = gl.createTexture();
	        Myprogram.texture.image = new Image();
	        Myprogram.texture.image.onload = function () {
				gl.bindTexture(gl.TEXTURE_2D, Myprogram.texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, Myprogram.texture.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.bindTexture(gl.TEXTURE_2D, null);
	        }
	        Myprogram.texture.image.src = src;
	    }

		function generateTangents(vertices, normals, texCoords, indices)
		{
			let tangents = new Float32Array(vertices.length);
			// Initialize tangents to zero
			for (let i = 0; i < tangents.length; i++) {
				tangents[i] = 0;
			}
			// For each triangle
			for (let i = 0; i < indices.length; i += 3) {
				let i0 = indices[i];
				let i1 = indices[i + 1];
				let i2 = indices[i + 2];
				let v0 = [vertices[i0 * 3], vertices[i0 * 3 + 1], vertices[i0 * 3 + 2]];
				let v1 = [vertices[i1 * 3], vertices[i1 * 3 + 1], vertices[i1 * 3 + 2]];
				let v2 = [vertices[i2 * 3], vertices[i2 * 3 + 1], vertices[i2 * 3 + 2]];
				let uv0 = [texCoords[i0 * 2], texCoords[i0 * 2 + 1]];
				let uv1 = [texCoords[i1 * 2], texCoords[i1 * 2 + 1]];
				let uv2 = [texCoords[i2 * 2], texCoords[i2 * 2 + 1]];
				let deltaPos1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
				let deltaPos2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];
				let deltaUV1 = [uv1[0] - uv0[0], uv1[1] - uv0[1]];
				let deltaUV2 = [uv2[0] - uv0[0], uv2[1] - uv0[1]];
				let r = 1.0 / (deltaUV1[0] * deltaUV2[1] - deltaUV2[0] * deltaUV1[1]);
				if (isFinite(r)) {
					let tangent = [
						r * (deltaPos1[0] * deltaUV2[1] - deltaPos2[0] * deltaUV1[1]),
						r * (deltaPos1[1] * deltaUV2[1] - deltaPos2[1] * deltaUV1[1]),
						r * (deltaPos1[2] * deltaUV2[1] - deltaPos2[2] * deltaUV1[1])
					];
					tangents[i0 * 3] += tangent[0];
					tangents[i0 * 3 + 1] += tangent[1];
					tangents[i0 * 3 + 2] += tangent[2];
					tangents[i1 * 3] += tangent[0];
					tangents[i1 * 3 + 1] += tangent[1];
					tangents[i1 * 3 + 2] += tangent[2];
					tangents[i2 * 3] += tangent[0];
					tangents[i2 * 3 + 1] += tangent[1];
					tangents[i2 * 3 + 2] += tangent[2];
				}
			}
			// Orthogonalize and normalize
			for (let i = 0; i < vertices.length / 3; i++) {
				let n = [normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]];
				let t = [tangents[i * 3], tangents[i * 3 + 1], tangents[i * 3 + 2]];
				// Dot product
				let dot = n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
				// Subtract projection
				t[0] -= n[0] * dot;
				t[1] -= n[1] * dot;
				t[2] -= n[2] * dot;
				// Normalize
				let len = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
				if (len > 0) {
					t[0] /= len;
					t[1] /= len;
					t[2] /= len;
				}
				tangents[i * 3] = t[0];
				tangents[i * 3 + 1] = t[1];
				tangents[i * 3 + 2] = t[2];
			}
			return tangents;
		}

		function loadNormalTexture(my3DObject, src)
		{
			let Myprogram = my3DObject.getProgram();
	        Myprogram.normalTexture = gl.createTexture();
	        Myprogram.normalTexture.image = new Image();
			
			Myprogram.normalTexture.image.onload = function () {
				gl.bindTexture(gl.TEXTURE_2D, Myprogram.normalTexture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, Myprogram.normalTexture.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.bindTexture(gl.TEXTURE_2D, null);
			}
	        Myprogram.normalTexture.image.src = src;
		}

		function updateBuffers()
		{
			// no dynamic buffers to update in this example
		}

		function drawMy3DObject(my3DObject)
		{
			let Myprogram = my3DObject.getProgram();
			let lwMatrix = my3DObject.getMatrix();

			// Activate program first
			gl.useProgram(Myprogram);

			// Update matrix uniforms
			updateMatrixUniforms(Myprogram);
			gl.uniformMatrix4fv(Myprogram.lwMatrixUniform, false, lwMatrix );

			// Position attribute (only enable if valid)
			if (Myprogram.vertexPositionAttribute >= 0) {
				gl.enableVertexAttribArray(Myprogram.vertexPositionAttribute);
				gl.bindBuffer(gl.ARRAY_BUFFER, my3DObject.OBJ.vertexBuffer);
				var itemSize = my3DObject.OBJ.vertexBuffer.itemSize || 3;
				gl.vertexAttribPointer(Myprogram.vertexPositionAttribute, itemSize, gl.FLOAT, false, 0, 0);
			} else {
				// fallback: do nothing if attribute not used by this shader
			}


			// For Textured objects:
			// Bind textures and set sampler uniforms (albedo -> unit 0, normal -> unit 1)
			let samplerLoc = gl.getUniformLocation(Myprogram, "uSampler");
			let normalSamplerLoc = gl.getUniformLocation(Myprogram, "uNormalSampler");
			let uniformLightDirLoc = gl.getUniformLocation(Myprogram, "uLightDirection");
			if (samplerLoc) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, Myprogram.texture);
				gl.uniform1i(samplerLoc, 0);
				// Object 2 not arriving 
			}
			if (normalSamplerLoc) {
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, Myprogram.normalTexture);
				gl.uniform1i(normalSamplerLoc, 1);
			}
			if (uniformLightDirLoc) {
				gl.uniform3fv(uniformLightDirLoc, mainDirectionLight);
				console.log("Uploaded light direction: " + mainDirectionLight);
			}

			// Texture coords if present in shader and mesh
			if (Myprogram.vertexNormalAttribute >= 0 && my3DObject.OBJ.vertexNormals.length) {
				gl.enableVertexAttribArray(Myprogram.vertexNormalAttribute);
				gl.bindBuffer(gl.ARRAY_BUFFER, my3DObject.OBJ.normalBuffer);
				var itemSize = my3DObject.OBJ.normalBuffer.itemSize || 3;
				gl.vertexAttribPointer(Myprogram.vertexNormalAttribute, itemSize, gl.FLOAT, false, 0, 0);
			} else if (Myprogram.vertexNormalAttribute >= 0) {
				gl.disableVertexAttribArray(Myprogram.vertexNormalAttribute);
			}

			if (Myprogram.textureCoordAttribute >= 0 && my3DObject.OBJ.textures.length) {
				gl.enableVertexAttribArray(Myprogram.textureCoordAttribute);
				gl.bindBuffer(gl.ARRAY_BUFFER, my3DObject.OBJ.textureBuffer);
				gl.vertexAttribPointer(Myprogram.textureCoordAttribute, my3DObject.OBJ.textureBuffer.itemSize, gl.FLOAT, false, 0, 0);
			} else if (Myprogram.textureCoordAttribute >= 0) {
				gl.disableVertexAttribArray(Myprogram.textureCoordAttribute);
			}

			// Binding the triangle index buffer and drawing
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, my3DObject.OBJ.indexBuffer);
			gl.drawElements(gl.TRIANGLES, my3DObject.OBJ.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);	

		}

		function drawScene()
		{
			for (let obj of mySceneObjects) {
				drawMy3DObject(obj);
			}
		}

		function initMatrixUniforms(myglProgram){
			myglProgram.pMatrixUniform = gl.getUniformLocation(myglProgram, "uPMatrix");
			myglProgram.vMatrixUniform = gl.getUniformLocation(myglProgram, "uVMatrix");
			myglProgram.lwMatrixUniform = gl.getUniformLocation(myglProgram, "uLWMatrix");
		}

		function updateMatrixUniforms(myglProgram) {
			// make sure the correct program is active when updating its uniforms
			if (!myglProgram) return;
			gl.useProgram(myglProgram);
			if (myglProgram.pMatrixUniform)
				gl.uniformMatrix4fv(myglProgram.pMatrixUniform, false, pMatrix);
			if (myglProgram.vMatrixUniform)
				gl.uniformMatrix4fv(myglProgram.vMatrixUniform, false, vMatrix);
			// per-object lw matrices are uploaded per-instance in drawScene
		}

		function initMy3DObject(my3DObject, vs_source, fs_source)
		{
			initBuffers(my3DObject);
			initShaders(my3DObject, vs_source, fs_source);
			initMatrixUniforms(my3DObject.getProgram());
		}

		function readTextFile(file)
		{
		    let rawFile = new XMLHttpRequest();
		    let strText;
		    rawFile.open("GET", file, false);
		    rawFile.onreadystatechange = function ()
		    {
		        if(rawFile.readyState === 4)
		        {
		            if(rawFile.status === 200 || rawFile.status == 0)
		            {
		                strText = rawFile.responseText;
		            }
		        }
		    }
		    rawFile.send(null);
		    return strText;
		}

	</script>

</head>

<body onload="initWebGL()">
	<canvas id="my-canvas" width="1000" height="800">
		Your browser does not support the HTML5 canvas element.
	</canvas>
</body>

</html>